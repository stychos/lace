#!/usr/bin/env python3
"""
Generate a test SQLite database with fake data for testing lace.
Creates ~12 tables with relations, thousands of rows each,
and one table with millions of rows.
"""

import sqlite3
import random
import string
import os
from datetime import datetime, timedelta

# Configuration
DB_PATH = "data.sqlite"
BATCH_SIZE = 10000

# Table sizes
NUM_USERS = 5000
NUM_CATEGORIES = 200
NUM_PRODUCTS = 8000
NUM_SUPPLIERS = 300
NUM_TAGS = 500
NUM_ADDRESSES = 6000
NUM_ORDERS = 50000
NUM_ORDER_ITEMS = 2_000_000  # The big one
NUM_REVIEWS = 30000
NUM_PAYMENTS = 50000
NUM_INVENTORY_LOGS = 100000
NUM_PRODUCT_TAGS = 20000

# Force unbuffered output
import sys
sys.stdout.reconfigure(line_buffering=True)

# Fake data generators
FIRST_NAMES = ["James", "Mary", "John", "Patricia", "Robert", "Jennifer", "Michael", "Linda",
               "William", "Elizabeth", "David", "Barbara", "Richard", "Susan", "Joseph", "Jessica",
               "Thomas", "Sarah", "Charles", "Karen", "Christopher", "Nancy", "Daniel", "Lisa",
               "Matthew", "Betty", "Anthony", "Margaret", "Mark", "Sandra", "Donald", "Ashley",
               "Steven", "Kimberly", "Paul", "Emily", "Andrew", "Donna", "Joshua", "Michelle",
               "Ivan", "Olga", "Dmitry", "Anna", "Sergei", "Elena", "Alexei", "Natasha"]

LAST_NAMES = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis",
              "Rodriguez", "Martinez", "Hernandez", "Lopez", "Gonzalez", "Wilson", "Anderson",
              "Thomas", "Taylor", "Moore", "Jackson", "Martin", "Lee", "Perez", "Thompson",
              "White", "Harris", "Sanchez", "Clark", "Ramirez", "Lewis", "Robinson", "Walker",
              "Young", "Allen", "King", "Wright", "Scott", "Torres", "Nguyen", "Hill", "Flores",
              "Ivanov", "Petrov", "Sidorov", "Kozlov", "Novikov", "Morozov", "Volkov", "Sokolov"]

STREETS = ["Main St", "Oak Ave", "Pine Rd", "Maple Dr", "Cedar Ln", "Elm St", "Washington Blvd",
           "Park Ave", "Lake Dr", "Hill Rd", "River St", "Forest Ave", "Sunset Blvd", "Ocean Dr",
           "Mountain View Rd", "Valley Rd", "Spring St", "Garden Ave", "Church St", "School Rd"]

CITIES = ["New York", "Los Angeles", "Chicago", "Houston", "Phoenix", "Philadelphia", "San Antonio",
          "San Diego", "Dallas", "San Jose", "Austin", "Jacksonville", "Fort Worth", "Columbus",
          "San Francisco", "Charlotte", "Indianapolis", "Seattle", "Denver", "Boston", "Portland",
          "Moscow", "Saint Petersburg", "Tiraspol", "London", "Paris", "Berlin", "Tokyo", "Sydney"]

COUNTRIES = ["Russia", "Greece", "Italy", "USA", "UK", "Canada", "Germany", "France", "Australia", "Japan"]

CATEGORIES = ["Electronics", "Clothing", "Home & Garden", "Sports", "Books", "Toys", "Automotive",
              "Health", "Beauty", "Food", "Music", "Movies", "Software", "Office", "Pet Supplies",
              "Jewelry", "Shoes", "Furniture", "Appliances", "Tools"]

ADJECTIVES = ["Premium", "Deluxe", "Professional", "Essential", "Classic", "Modern", "Vintage",
              "Compact", "Portable", "Wireless", "Smart", "Eco-friendly", "Heavy-duty", "Lightweight",
              "Waterproof", "Ergonomic", "Adjustable", "Foldable", "Rechargeable", "Multi-purpose"]

PRODUCT_NOUNS = ["Widget", "Gadget", "Device", "Tool", "Kit", "Set", "Pack", "Bundle", "System",
                 "Unit", "Module", "Component", "Accessory", "Adapter", "Converter", "Controller",
                 "Sensor", "Monitor", "Tracker", "Organizer", "Holder", "Stand", "Case", "Cover"]

COLORS = ["Red", "Blue", "Green", "Black", "White", "Silver", "Gold", "Purple", "Orange", "Pink"]

PAYMENT_METHODS = ["Credit Card", "Debit Card", "PayPal", "Bank Transfer", "Cash", "Crypto"]
ORDER_STATUSES = ["pending", "processing", "shipped", "delivered", "cancelled", "refunded"]
REVIEW_TITLES = ["Great product!", "Disappointed", "Exactly as described", "Good value",
                 "Would recommend", "Not worth it", "Amazing quality", "Average", "Love it!", "Meh"]


def random_string(length):
    return ''.join(random.choices(string.ascii_letters, k=length))

_email_counter = 0
def random_email(first, last):
    global _email_counter
    _email_counter += 1
    domains = ["gmail.com", "yahoo.com", "hotmail.com", "outlook.com", "mail.com", "proton.me"]
    return f"{first.lower()}.{last.lower()}.{_email_counter}@{random.choice(domains)}"

def random_phone():
    return f"+1-{random.randint(200,999)}-{random.randint(100,999)}-{random.randint(1000,9999)}"

def random_date(start_year=2020, end_year=2024):
    start = datetime(start_year, 1, 1)
    end = datetime(end_year, 12, 31)
    delta = end - start
    random_days = random.randint(0, delta.days)
    return start + timedelta(days=random_days)

def random_datetime(start_year=2020, end_year=2024):
    d = random_date(start_year, end_year)
    return d.replace(hour=random.randint(0,23), minute=random.randint(0,59), second=random.randint(0,59))

def random_text(min_words=5, max_words=30):
    words = ["the", "a", "an", "this", "that", "it", "is", "was", "are", "were", "be", "been",
             "have", "has", "had", "do", "does", "did", "will", "would", "could", "should",
             "product", "quality", "price", "shipping", "delivery", "package", "item", "order",
             "great", "good", "bad", "excellent", "poor", "fast", "slow", "easy", "hard",
             "recommend", "buy", "return", "exchange", "refund", "satisfied", "disappointed",
             "love", "hate", "like", "dislike", "amazing", "terrible", "perfect", "broken"]
    return ' '.join(random.choices(words, k=random.randint(min_words, max_words))).capitalize() + '.'


def create_schema(conn):
    """Create all tables"""
    cursor = conn.cursor()

    cursor.executescript('''
        -- Users table
        CREATE TABLE users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            first_name TEXT NOT NULL,
            last_name TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL,
            phone TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            is_active BOOLEAN DEFAULT 1,
            bio TEXT
        );
        CREATE INDEX idx_users_email ON users(email);
        CREATE INDEX idx_users_name ON users(last_name, first_name);

        -- Categories table
        CREATE TABLE categories (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            description TEXT,
            parent_id INTEGER REFERENCES categories(id),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX idx_categories_parent ON categories(parent_id);

        -- Suppliers table
        CREATE TABLE suppliers (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            contact_name TEXT,
            email TEXT,
            phone TEXT,
            address TEXT,
            city TEXT,
            country TEXT,
            rating REAL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        -- Products table
        CREATE TABLE products (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            description TEXT,
            sku TEXT UNIQUE,
            price REAL NOT NULL,
            cost REAL,
            category_id INTEGER REFERENCES categories(id),
            supplier_id INTEGER REFERENCES suppliers(id),
            stock_quantity INTEGER DEFAULT 0,
            is_active BOOLEAN DEFAULT 1,
            weight REAL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX idx_products_category ON products(category_id);
        CREATE INDEX idx_products_supplier ON products(supplier_id);
        CREATE INDEX idx_products_sku ON products(sku);

        -- Tags table
        CREATE TABLE tags (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE NOT NULL,
            color TEXT
        );

        -- Product-Tags junction table
        CREATE TABLE product_tags (
            product_id INTEGER REFERENCES products(id),
            tag_id INTEGER REFERENCES tags(id),
            PRIMARY KEY (product_id, tag_id)
        );
        CREATE INDEX idx_product_tags_tag ON product_tags(tag_id);

        -- Addresses table
        CREATE TABLE addresses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER REFERENCES users(id),
            type TEXT CHECK(type IN ('billing', 'shipping')),
            street TEXT NOT NULL,
            city TEXT NOT NULL,
            state TEXT,
            postal_code TEXT,
            country TEXT NOT NULL,
            is_default BOOLEAN DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX idx_addresses_user ON addresses(user_id);

        -- Orders table
        CREATE TABLE orders (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER REFERENCES users(id),
            shipping_address_id INTEGER REFERENCES addresses(id),
            billing_address_id INTEGER REFERENCES addresses(id),
            status TEXT DEFAULT 'pending',
            subtotal REAL,
            tax REAL,
            shipping_cost REAL,
            total REAL,
            notes TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX idx_orders_user ON orders(user_id);
        CREATE INDEX idx_orders_status ON orders(status);
        CREATE INDEX idx_orders_created ON orders(created_at);

        -- Order items table (THE BIG ONE - millions of rows)
        CREATE TABLE order_items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_id INTEGER REFERENCES orders(id),
            product_id INTEGER REFERENCES products(id),
            quantity INTEGER NOT NULL,
            unit_price REAL NOT NULL,
            discount REAL DEFAULT 0,
            total REAL NOT NULL
        );
        CREATE INDEX idx_order_items_order ON order_items(order_id);
        CREATE INDEX idx_order_items_product ON order_items(product_id);

        -- Payments table
        CREATE TABLE payments (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            order_id INTEGER REFERENCES orders(id),
            method TEXT NOT NULL,
            amount REAL NOT NULL,
            status TEXT DEFAULT 'pending',
            transaction_id TEXT,
            processed_at TIMESTAMP,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX idx_payments_order ON payments(order_id);
        CREATE INDEX idx_payments_status ON payments(status);

        -- Reviews table
        CREATE TABLE reviews (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            product_id INTEGER REFERENCES products(id),
            user_id INTEGER REFERENCES users(id),
            rating INTEGER CHECK(rating >= 1 AND rating <= 5),
            title TEXT,
            content TEXT,
            is_verified_purchase BOOLEAN DEFAULT 0,
            helpful_count INTEGER DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX idx_reviews_product ON reviews(product_id);
        CREATE INDEX idx_reviews_user ON reviews(user_id);
        CREATE INDEX idx_reviews_rating ON reviews(rating);

        -- Inventory logs table
        CREATE TABLE inventory_logs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            product_id INTEGER REFERENCES products(id),
            change_type TEXT CHECK(change_type IN ('restock', 'sale', 'adjustment', 'return')),
            quantity_change INTEGER NOT NULL,
            quantity_before INTEGER,
            quantity_after INTEGER,
            reference_id INTEGER,
            notes TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX idx_inventory_logs_product ON inventory_logs(product_id);
        CREATE INDEX idx_inventory_logs_type ON inventory_logs(change_type);
    ''')

    conn.commit()
    print("Schema created successfully")


def insert_users(conn, count):
    print(f"Inserting {count} users...")
    cursor = conn.cursor()

    for batch_start in range(0, count, BATCH_SIZE):
        batch_end = min(batch_start + BATCH_SIZE, count)
        users = []
        for _ in range(batch_end - batch_start):
            first = random.choice(FIRST_NAMES)
            last = random.choice(LAST_NAMES)
            users.append((
                first, last,
                random_email(first, last),
                random_phone(),
                random_datetime().isoformat(),
                random_datetime().isoformat(),
                random.choice([0, 1, 1, 1, 1]),  # 80% active
                random_text(10, 50) if random.random() > 0.7 else None
            ))

        cursor.executemany('''
            INSERT INTO users (first_name, last_name, email, phone, created_at, updated_at, is_active, bio)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', users)
        conn.commit()
        print(f"  Users: {batch_end}/{count}")


def insert_categories(conn, count):
    print(f"Inserting {count} categories...")
    cursor = conn.cursor()

    categories = []
    for i, cat in enumerate(CATEGORIES):
        categories.append((cat, f"All {cat.lower()} products", None))

    # Add subcategories
    for i in range(count - len(CATEGORIES)):
        parent_id = random.randint(1, len(CATEGORIES))
        adj = random.choice(ADJECTIVES)
        base = random.choice(CATEGORIES)
        categories.append((
            f"{adj} {base}",
            f"Subcategory of {base}",
            parent_id
        ))

    cursor.executemany('''
        INSERT INTO categories (name, description, parent_id)
        VALUES (?, ?, ?)
    ''', categories)
    conn.commit()


def insert_suppliers(conn, count):
    print(f"Inserting {count} suppliers...")
    cursor = conn.cursor()

    suppliers = []
    for i in range(count):
        suppliers.append((
            f"{random.choice(ADJECTIVES)} {random.choice(['Industries', 'Corp', 'LLC', 'Inc', 'Co', 'Ltd'])}",
            f"{random.choice(FIRST_NAMES)} {random.choice(LAST_NAMES)}",
            f"supplier{i}@{random.choice(['business', 'company', 'corp'])}.com",
            random_phone(),
            f"{random.randint(1, 999)} {random.choice(STREETS)}",
            random.choice(CITIES),
            random.choice(COUNTRIES),
            round(random.uniform(1, 5), 2),
            random_datetime().isoformat()
        ))

    cursor.executemany('''
        INSERT INTO suppliers (name, contact_name, email, phone, address, city, country, rating, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', suppliers)
    conn.commit()


def insert_products(conn, count, num_categories, num_suppliers):
    print(f"Inserting {count} products...")
    cursor = conn.cursor()

    for batch_start in range(0, count, BATCH_SIZE):
        batch_end = min(batch_start + BATCH_SIZE, count)
        products = []
        for i in range(batch_start, batch_end):
            adj = random.choice(ADJECTIVES)
            noun = random.choice(PRODUCT_NOUNS)
            color = random.choice(COLORS)
            price = round(random.uniform(5, 500), 2)
            products.append((
                f"{adj} {color} {noun}",
                random_text(20, 100),
                f"SKU-{i:08d}",
                price,
                round(price * random.uniform(0.3, 0.7), 2),
                random.randint(1, num_categories),
                random.randint(1, num_suppliers),
                random.randint(0, 1000),
                random.choice([0, 1, 1, 1, 1]),
                round(random.uniform(0.1, 50), 2),
                random_datetime().isoformat(),
                random_datetime().isoformat()
            ))

        cursor.executemany('''
            INSERT INTO products (name, description, sku, price, cost, category_id, supplier_id,
                                  stock_quantity, is_active, weight, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', products)
        conn.commit()
        print(f"  Products: {batch_end}/{count}")


def insert_tags(conn, count):
    print(f"Inserting {count} tags...")
    cursor = conn.cursor()

    tag_words = ["sale", "new", "popular", "trending", "clearance", "limited", "exclusive",
                 "featured", "bestseller", "eco", "organic", "premium", "budget", "luxury",
                 "hot", "cool", "fresh", "vintage", "classic", "modern", "smart", "fast"]

    tags = []
    for i in range(count):
        tag = f"{random.choice(tag_words)}-{random.choice(ADJECTIVES).lower()}-{i}"
        tags.append((tag, random.choice(COLORS).lower()))

    cursor.executemany('''
        INSERT INTO tags (name, color)
        VALUES (?, ?)
    ''', tags)
    conn.commit()


def insert_product_tags(conn, count, num_products, num_tags):
    print(f"Inserting {count} product-tag relations...")
    cursor = conn.cursor()

    # Generate pairs without infinite loop risk
    pairs = []
    seen = set()
    attempts = 0
    max_attempts = count * 3
    while len(pairs) < count and attempts < max_attempts:
        pair = (random.randint(1, num_products), random.randint(1, num_tags))
        if pair not in seen:
            seen.add(pair)
            pairs.append(pair)
        attempts += 1

    cursor.executemany('''
        INSERT OR IGNORE INTO product_tags (product_id, tag_id)
        VALUES (?, ?)
    ''', pairs)
    conn.commit()
    print(f"  Product tags: {len(pairs)}/{count}")


def insert_addresses(conn, count, num_users):
    print(f"Inserting {count} addresses...")
    cursor = conn.cursor()

    for batch_start in range(0, count, BATCH_SIZE):
        batch_end = min(batch_start + BATCH_SIZE, count)
        addresses = []
        for _ in range(batch_end - batch_start):
            addresses.append((
                random.randint(1, num_users),
                random.choice(['billing', 'shipping']),
                f"{random.randint(1, 9999)} {random.choice(STREETS)}",
                random.choice(CITIES),
                random_string(2).upper(),
                f"{random.randint(10000, 99999)}",
                random.choice(COUNTRIES),
                random.choice([0, 0, 0, 1]),
                random_datetime().isoformat()
            ))

        cursor.executemany('''
            INSERT INTO addresses (user_id, type, street, city, state, postal_code, country, is_default, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', addresses)
        conn.commit()
        print(f"  Addresses: {batch_end}/{count}")


def insert_orders(conn, count, num_users, num_addresses):
    print(f"Inserting {count} orders...")
    cursor = conn.cursor()

    for batch_start in range(0, count, BATCH_SIZE):
        batch_end = min(batch_start + BATCH_SIZE, count)
        orders = []
        for _ in range(batch_end - batch_start):
            subtotal = round(random.uniform(10, 1000), 2)
            tax = round(subtotal * 0.08, 2)
            shipping = round(random.uniform(0, 20), 2)
            orders.append((
                random.randint(1, num_users),
                random.randint(1, num_addresses),
                random.randint(1, num_addresses),
                random.choice(ORDER_STATUSES),
                subtotal, tax, shipping,
                round(subtotal + tax + shipping, 2),
                random_text(5, 20) if random.random() > 0.8 else None,
                random_datetime().isoformat(),
                random_datetime().isoformat()
            ))

        cursor.executemany('''
            INSERT INTO orders (user_id, shipping_address_id, billing_address_id, status,
                               subtotal, tax, shipping_cost, total, notes, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', orders)
        conn.commit()
        print(f"  Orders: {batch_end}/{count}")


def insert_order_items(conn, count, num_orders, num_products):
    print(f"Inserting {count} order items (this will take a while)...")
    cursor = conn.cursor()

    for batch_start in range(0, count, BATCH_SIZE):
        batch_end = min(batch_start + BATCH_SIZE, count)
        items = []
        for _ in range(batch_end - batch_start):
            qty = random.randint(1, 10)
            price = round(random.uniform(5, 200), 2)
            discount = round(random.uniform(0, price * 0.3), 2) if random.random() > 0.7 else 0
            items.append((
                random.randint(1, num_orders),
                random.randint(1, num_products),
                qty,
                price,
                discount,
                round((price - discount) * qty, 2)
            ))

        cursor.executemany('''
            INSERT INTO order_items (order_id, product_id, quantity, unit_price, discount, total)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', items)
        conn.commit()
        if batch_end % 100000 == 0 or batch_end == count:
            print(f"  Order items: {batch_end:,}/{count:,}")


def insert_payments(conn, count, num_orders):
    print(f"Inserting {count} payments...")
    cursor = conn.cursor()

    for batch_start in range(0, count, BATCH_SIZE):
        batch_end = min(batch_start + BATCH_SIZE, count)
        payments = []
        for _ in range(batch_end - batch_start):
            payments.append((
                random.randint(1, num_orders),
                random.choice(PAYMENT_METHODS),
                round(random.uniform(10, 1000), 2),
                random.choice(['pending', 'completed', 'failed', 'refunded']),
                f"TXN-{random_string(16).upper()}",
                random_datetime().isoformat(),
                random_datetime().isoformat()
            ))

        cursor.executemany('''
            INSERT INTO payments (order_id, method, amount, status, transaction_id, processed_at, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', payments)
        conn.commit()
        print(f"  Payments: {batch_end}/{count}")


def insert_reviews(conn, count, num_products, num_users):
    print(f"Inserting {count} reviews...")
    cursor = conn.cursor()

    for batch_start in range(0, count, BATCH_SIZE):
        batch_end = min(batch_start + BATCH_SIZE, count)
        reviews = []
        for _ in range(batch_end - batch_start):
            reviews.append((
                random.randint(1, num_products),
                random.randint(1, num_users),
                random.randint(1, 5),
                random.choice(REVIEW_TITLES),
                random_text(20, 150),
                random.choice([0, 1]),
                random.randint(0, 100),
                random_datetime().isoformat()
            ))

        cursor.executemany('''
            INSERT INTO reviews (product_id, user_id, rating, title, content,
                                is_verified_purchase, helpful_count, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', reviews)
        conn.commit()
        print(f"  Reviews: {batch_end}/{count}")


def insert_inventory_logs(conn, count, num_products):
    print(f"Inserting {count} inventory logs...")
    cursor = conn.cursor()

    for batch_start in range(0, count, BATCH_SIZE):
        batch_end = min(batch_start + BATCH_SIZE, count)
        logs = []
        for _ in range(batch_end - batch_start):
            change_type = random.choice(['restock', 'sale', 'adjustment', 'return'])
            qty_before = random.randint(0, 500)
            qty_change = random.randint(-50, 100)
            logs.append((
                random.randint(1, num_products),
                change_type,
                qty_change,
                qty_before,
                max(0, qty_before + qty_change),
                random.randint(1, 10000) if change_type in ['sale', 'return'] else None,
                random_text(5, 15) if random.random() > 0.8 else None,
                random_datetime().isoformat()
            ))

        cursor.executemany('''
            INSERT INTO inventory_logs (product_id, change_type, quantity_change,
                                        quantity_before, quantity_after, reference_id, notes, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', logs)
        conn.commit()
        print(f"  Inventory logs: {batch_end}/{count}")


def main():
    # Remove existing database
    if os.path.exists(DB_PATH):
        os.remove(DB_PATH)
        print(f"Removed existing {DB_PATH}")

    conn = sqlite3.connect(DB_PATH)
    conn.execute("PRAGMA journal_mode=WAL")
    conn.execute("PRAGMA synchronous=NORMAL")

    try:
        create_schema(conn)

        insert_users(conn, NUM_USERS)
        insert_categories(conn, NUM_CATEGORIES)
        insert_suppliers(conn, NUM_SUPPLIERS)
        insert_products(conn, NUM_PRODUCTS, NUM_CATEGORIES, NUM_SUPPLIERS)
        insert_tags(conn, NUM_TAGS)
        insert_product_tags(conn, NUM_PRODUCT_TAGS, NUM_PRODUCTS, NUM_TAGS)
        insert_addresses(conn, NUM_ADDRESSES, NUM_USERS)
        insert_orders(conn, NUM_ORDERS, NUM_USERS, NUM_ADDRESSES)
        insert_order_items(conn, NUM_ORDER_ITEMS, NUM_ORDERS, NUM_PRODUCTS)
        insert_payments(conn, NUM_PAYMENTS, NUM_ORDERS)
        insert_reviews(conn, NUM_REVIEWS, NUM_PRODUCTS, NUM_USERS)
        insert_inventory_logs(conn, NUM_INVENTORY_LOGS, NUM_PRODUCTS)

        # Print summary
        print("\n" + "="*50)
        print("Database generation complete!")
        print("="*50)

        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
        tables = cursor.fetchall()

        print(f"\nTables ({len(tables)}):")
        for (table,) in tables:
            cursor.execute(f"SELECT COUNT(*) FROM {table}")
            count = cursor.fetchone()[0]
            print(f"  {table}: {count:,} rows")

        # File size
        conn.close()
        size_mb = os.path.getsize(DB_PATH) / (1024 * 1024)
        print(f"\nDatabase size: {size_mb:.1f} MB")
        print(f"Location: {os.path.abspath(DB_PATH)}")

    except Exception as e:
        print(f"Error: {e}")
        conn.close()
        raise


if __name__ == "__main__":
    main()
